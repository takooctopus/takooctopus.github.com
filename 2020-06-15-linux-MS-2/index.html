<!DOCTYPE HTML>
<html>

<head>
	<!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="bookmark"  type="image/x-icon"  href="/img/logo_tako.jpg"/>
	<link rel="shortcut icon" href="/img/logo_tako.jpg">
	
			    <title>
    TAKONOHEYA
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="takooctopus takonoheya" />
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
          processEscapes: true
        },
        TeX: {
          equationNumbers: {
            autoNumber: "AMS"
          }
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    
    <script async type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  

 
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"><!-- hexo-inject:begin --><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.min.css'><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.css'><!-- hexo-inject:end --></head>
    
		
<!-- Layouts -->


<link rel="stylesheet" href="/css/prism_okaidia.css" />

<link rel="stylesheet" href="/css/typo.css" />

<!-- 文章页 -->
<body class="is-loading">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">TAKOOCTOPUS</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简介">
		                简介
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/series/" title="系列">
		                系列
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/takooctopus" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="tv" href="https://space.bilibili.com/499056" target="_blank" rel="noopener">
                            <i class="icon fa fa-tv"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="home" href="https://takooctopus.github.io" target="_blank" rel="noopener">
                            <i class="icon fa fa-home"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/assets/img/posts/Linux/ms.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >PBS使用手册</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <blockquote>
<p>本文作为<a href="https://takooctopus.github.io/" title="TAKONOHEYA">本人@takooctopus</a>深入学习用于MS上一点教程摘录，这个博客遵照着<a target="_blank" rel="noopener" href="http://www.ihb.cas.cn/" title="中科院水生生物研究所">中科院水生生物研究所</a>和<a target="_blank" rel="noopener" href="http://bicmr.pku.edu.cn/" title="北京数学国际研究中心">北京数学国际研究中心</a>等一干网站的教程，特此列出，表示感谢。</p>
</blockquote>
<h1 id="pbs简介"><a class="markdownIt-Anchor" href="#pbs简介"></a> PBS简介</h1>
<p>PBS是公开源代码的作业管理系统，在此环境下运行，用户不需要指定程序在哪些节点上运行，程序所需的硬件资源由PBS管理和分配。</p>
<p>PBS(Portable Batch System)是由NASA开发的灵活的批处理系统。它被用于集群系统、超级计算机和大规模并行系统。PBS主要有如下特征：</p>
<ul>
<li><strong>易用性：</strong> 为所有的资源提供统一的接口，易于配置以满足不同系统的需求，灵活的作业调度器允许不同系统采用自己的调度策略。</li>
<li><strong>移植性：</strong> 符合POSIX 1003.2标准，可以用于shell和批处理等各种环境。</li>
<li><strong>适配性：</strong> 可以适配与各种管理策略，并提供可扩展的认证和安全模型。支持广域网上的负载的动态分发和建立在多个物理位置不同的实体上的虚拟组织。</li>
<li><strong>灵活性：</strong> 支持交互和批处理作业。</li>
</ul>
<h1 id="pbs命令简介"><a class="markdownIt-Anchor" href="#pbs命令简介"></a> PBS命令简介</h1>
<p>因为PBS是部署于超算集群的，我们的作业或者说是提交任务的任务是需要排队的，作业通过PBS命令提交到PBS队列中，然后经由PBS分配资源运行。</p>
<p>一般的，我们咨询超算管理员关于队列的信息介绍，一般会分成几个队列，分别对应于不同目标的作业要求。比方说默认用于作业测试的batch，或者什么old，fat啥的，要记住，这个只是一个队列代号而已，由超算集群管理员定义，我们只需要明白自己作业对应于哪一个队列最为合适即可。</p>
<p>PBS提供四条基本的命令用于作业管理。</p>
<h2 id="1-qsub-用于提交作业脚本"><a class="markdownIt-Anchor" href="#1-qsub-用于提交作业脚本"></a> (1) qsub —— 用于提交作业脚本</h2>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>因为所采用的选项一般放在pbs脚本中提交，所以具体见PBS脚本选项。</p>
<p>例如:</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<h2 id="2-qstat-命令-用于查询作业状态信息"><a class="markdownIt-Anchor" href="#2-qstat-命令-用于查询作业状态信息"></a> (2) qstat 命令 —— 用于查询作业状态信息</h2>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>常用命令示例：</p>
<ul>
<li>查看空闲节点信息（提交作业前需要查看一下各队列节点空闲状况）</li>
</ul>
<img src="/2020-06-15-linux-MS-2/pbs_01.png" class="">
<ul>
<li>查看指定作业信息（提交作业后查看作业状态信息）</li>
</ul>
<img src="/2020-06-15-linux-MS-2/pbs_02.png" class="">
<ul>
<li>查看所有队列作业状态</li>
</ul>
<img src="/2020-06-15-linux-MS-2/pbs_03.png" class="">
<h2 id="3-qdel-命令-用于删除已提交的作业"><a class="markdownIt-Anchor" href="#3-qdel-命令-用于删除已提交的作业"></a> (3) qdel 命令 —— 用于删除已提交的作业</h2>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>例：</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<h2 id="4-qmgr-命令-用于队列管理"><a class="markdownIt-Anchor" href="#4-qmgr-命令-用于队列管理"></a> (4) qmgr 命令 —— 用于队列管理</h2>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<h2 id="5qhold-qrls-作业挂起-作业释放"><a class="markdownIt-Anchor" href="#5qhold-qrls-作业挂起-作业释放"></a> （5）qhold &amp; qrls —— 作业挂起 &amp; 作业释放</h2>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>使用 <code>qhold</code> 命令可以挂起作业，使其不被调度执行；<br />
使用 <code>qrls</code> 命令可以将挂起的作业释放，使之可以被调度执行；</p>
<h1 id="pbs脚本文件"><a class="markdownIt-Anchor" href="#pbs脚本文件"></a> PBS脚本文件</h1>
<p>PBS脚本文件由脚本选项和运行脚本两部分组成。</p>
<h2 id="1-pbs-作业脚本选项-若无-c选项则每项前面加pbs"><a class="markdownIt-Anchor" href="#1-pbs-作业脚本选项-若无-c选项则每项前面加pbs"></a> (1) PBS 作业脚本选项 （若无-C选项，则每项前面加‘#PBS’）</h2>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<h2 id="2-运行脚本同linux下一般的运行脚本文件"><a class="markdownIt-Anchor" href="#2-运行脚本同linux下一般的运行脚本文件"></a> (2) 运行脚本同LINUX下一般的运行脚本文件。</h2>
<p>[注]：脚本文件中的<code>mpirun_rsh</code>命令行中的节点列表文件要用环境变量表示<br />
<code>$PBS_NODEFILE</code>(随便你们怎么赋值，反正是一个变量)，这个环境变量表示由pbs自动分配给作业的节点列表；<br />
节点数为命令行中指定的进程数。<br />
格式如下：</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<h1 id="pbs环境下运行示例"><a class="markdownIt-Anchor" href="#pbs环境下运行示例"></a> PBS环境下运行示例</h1>
<h2 id="1脚本文件编辑示例"><a class="markdownIt-Anchor" href="#1脚本文件编辑示例"></a> （1）脚本文件编辑示例</h2>
<h3 id="a示例一运行mpi程序"><a class="markdownIt-Anchor" href="#a示例一运行mpi程序"></a> (A)示例一：运行mpi程序</h3>
<p>命令行(bash)命令：<br />
使用vi或者vim编辑PBS配置文件<code>foo.pbs</code>：</p>
<p><label class="label-theorem"> 注意： 在命令行中的 <strong>#</strong> 和文件脚本中的 <strong>#</strong> 意义不同。</label></p>
<ul>
<li>在命令行中<code>#</code>代表管理员</li>
<li>在脚本中就是单纯的<code>#</code>，有时候脚本中可能表示注解。</li>
<li><code>~</code>: 命令行中为帐户的 home 目录。</li>
<li><code>;</code>: 分号，命令行中用以分隔连续指令。</li>
</ul>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>编辑的内容为：<br />
<label class="label-theorem"> 注意： 代码中 <strong>[]</strong> 括出的是我注释的文件路径信息，其实这文件放在哪儿都无所谓，你找得到就行。</label></p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p><strong>解释：</strong></p>
<p>原先大家都是在终端(bash)输入<code>mpirun_rsh......</code>这些命令执行程序的，现在只要把这些提交命令放在<code>.pbs</code>配置文件的最后，由 <strong>PBS</strong> 来调度执行 （自动分配节点和其它资源）。</p>
<p><code>myjob</code>是为你此次要运行的程序起的任务名，可以改成你自己想要的名字，原来输出信息都是直接在屏幕上显示的，现在屏幕上的显示全部会输出到文件中，上例中输出文件是<code>/home/jz/my.out</code>文件，可以根据自己的需要修改（目录，文件名）。程序运行时遇到的一些错误会 记录在<code>.err</code>文件中。好处:因为对每个任务都设定了不同的输出文件，所以看结果只要打开相应文件看就可以了，不需要开多个终端，里面有任务的详细信息， 比如实际分配的是哪些节点计算，运行时间等。</p>
<p><code>pbs -l nodes=2:ppn=2</code>规定使用的节点数，以及每个节点能跑多少核，它们的积即是需要用的CPU数目。</p>
<p><code>mpirun –np 4 –hostfile $PBS_NODEFILE /home/jz/helloworld</code> 此例中<code>-np</code>后的<code>4</code>是并行数（2×2＝4个cpu），也就是上一个命令里CPU的数目，<code>–hostfile $PBS_NODEFILE</code>不需要改变（毕竟这都是环境变量了，自己赋值吧）。<code>/home/jz/helloworld</code>是你编译好的可执行文件名，需修改。</p>
<p>对于每个你要运行的 mpi 程序都需要这样一个<code>.pbs</code> 配置文件，也就是说原来的操作是：<code>mpirun……</code>，现在改成 2 步走：</p>
<ul>
<li><strong>1）</strong> 写个 PBS 配置文件（比如 xxx.pbs）；</li>
<li><strong>2）</strong> 向 PBS 提交（qsub xxx.pbs）</li>
</ul>
<h3 id="b实例二运行非mpi程序"><a class="markdownIt-Anchor" href="#b实例二运行非mpi程序"></a> (B)实例二：运行非mpi程序</h3>
<p>有些用户并不是自己编写mpi程序，同样也可以用pbs提交。</p>
<p>比如物理系运行程序时一般输入的命令是</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>那么配置文件可以这样写：</p>
<p>先命令行创建PBS配置文件：</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>其中配置文件内容为</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>解释：也就是说把原来在终端直接输入的命令<code>RunDMol3.sh TiFeCp2-pbe-dspp-m=1-opt</code>放到pbs配置文件中，因为你们只要一个节点，所以<code>nodes=1</code>，至于用哪个节点系统自动分配，你们 肯定很关心是分配了哪个节点给你们，那么可以用<code>qstat</code>命令查询（比如qstat -n）。</p>
<h3 id="实例三标准pbs配置文件模板"><a class="markdownIt-Anchor" href="#实例三标准pbs配置文件模板"></a> ©实例三：标准PBS配置文件模板</h3>
<p><label class="label-example"> 注意： 此为标准PBS配置文件模板。</label></p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>视情况可以删减一些配置语句。</p>
<h3 id="用户脚本文件实例"><a class="markdownIt-Anchor" href="#用户脚本文件实例"></a> 用户脚本文件实例</h3>
<ul>
<li>实例一</li>
</ul>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<ul>
<li>实例二</li>
</ul>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<h2 id="2提交作业示例"><a class="markdownIt-Anchor" href="#2提交作业示例"></a> （2）提交作业示例</h2>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>作业提交后会有一个作业号，即命令行上会显示：</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<h2 id="3-作业状态查询示例"><a class="markdownIt-Anchor" href="#3-作业状态查询示例"></a> (3) 作业状态查询示例</h2>
<p><code>qstat</code> 后加不同参数可以查看不同的信息（各参数的意思，上面有详细的说明，你们可以一个个试验一下，以后就知道查看哪些信息，需要哪些参数）</p>
<p>实例：</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>解释：Job id 是给你提交的任务分配的任务号，S（任务状态，R表示正在运行，Q表示正在排队等候调度）</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<p>解释：该方式输出和默认略有不同，但大同小异。</p>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>

<!-- Has Prism -->
<pre class="{{ pre_class }}" style="{{ pre_style }}" {{ data_attr }}><code class="language-&#123;&#123; lang &#125;&#125;">
&#123;&#123;- code -&#125;&#125;
</code></pre>
<h1 id="附录-关于使用vi进行脚本编辑"><a class="markdownIt-Anchor" href="#附录-关于使用vi进行脚本编辑"></a> 附录 关于使用Vi进行脚本编辑</h1>
<p>虽然有很多教程了，还是简单列出一点基础使用方法。</p>
<p>在Linux系统下，使用Vi编辑脚本。</p>
<ul>
<li>
<p><strong>一、进入vi</strong></p>
<p>系统提示符下，输入vi ＜文件名＞，vi 载入此文件或开启一个新文件（如果该文件不存在）。</p>
</li>
<li>
<p><strong>二、两种模式</strong><br />
vi存在两种模式：指令模式和输入模式。指令模式切换到输入模式需键入输入命令“a、i、o、A、I、O”，从输入模式切换到指令模式，按<code>ESC</code>键即可。</p>
<ul>
<li>
<p><strong>新增 (append)</strong><br />
a ：从光标所在位置後面开始新增资料，光标後的资料随新增资料向後移动。<br />
A：从光标所在列最後面的地方开始新增资料。</p>
</li>
<li>
<p><strong>插入 (insert)</strong><br />
i：从光标所在位置前面开始插入资料，光标後的资料随新增资料向後移动。<br />
I ：从光标所在列的第一个非空白字元前面开始插入资料。</p>
</li>
<li>
<p><strong>开始 (open)</strong><br />
o ：在光标所在列下新增一列并进入输入模式。<br />
O: 在光标所在列上方新增一列并进入输入模式。</p>
</li>
</ul>
</li>
<li>
<p><strong>三、退出vi</strong></p>
<p>指令模式下键入:wq、:q、:q!，退出vi。其中:wq是存盘退出，:q是直接退出，:q!强制退出。</p>
</li>
<li>
<p><strong>四、常用命令</strong></p>
<p><strong>x：</strong> 删除光标所在字符。<br />
<strong>dd ：</strong> 删除光标所在的列。<br />
<strong>r ：</strong> 修改光标所在字元，r 後接著要修正的字符。<br />
<strong>R：</strong> 进入取替换状态，新增文字会覆盖原先文字，直到按 [ESC] 回到指令模式下为止。<br />
<strong>s：</strong> 删除光标所在字元，并进入输入模式。<br />
<strong>S：</strong> 删除光标所在的列，并进入输入模式。</p>
</li>
</ul>

            </div>

            <!-- Post Comments -->
            

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
        </div>
    </div>
    <script src="/js/prism.js"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({{ JSON.stringify(config) }});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="{{ src }}">
</script>
<!-- End: Injected MathJax -->
<script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js'></script><script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/line-numbers/prism-line-numbers.min.js'></script><script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js'></script><!-- hexo-inject:end -->
</body>



 	
</html>
